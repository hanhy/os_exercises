#lec 3 SPOC Discussion

## 第三讲 启动、中断、异常和系统调用-思考题

## 3.1 BIOS
 1. 比较UEFI和BIOS的区别。
 >UEFI在安全性和兼容性和易开发性以及速度上上面都优于BIOS
 BIOS最大的缺点是平台相关，不同的系统有不同的引导，而这些引导程序都是写在固定的一段存储区的，这段存储区的
 大小是512字节，而且，这段代码只能是16位代码写的，当引导代码的大小超过512字节的时候，BIOS就无能为力了，且其
 硬件服务程序也都是16位代码，在增强模式下访问这些服务的时候非常困难。而且如果运行的这一段程序是恶意的，BIOS
 并不能提供有效的检测、排除功能。UEFI制订了一个可信启动流程，
 该流程运行起来之后，在读磁盘上的引导记录的时候，会对这个引导记录的可信性进行一个检查，只有满足既定签名的引
 导记录才会读进来，并交出控制权，减少了启动阶段产生的风险。还有就是易开发性，BIOS的所有硬件服务都是基于16位
 寻址模式的，UEFI则是运行于32或64位环境的，不仅检错容错性大大增加，速度也变得更快。
 1. 描述PXE的大致启动流程。
 PXE是从网络加载操作系统的一种形式，工作在C/S模式下，其大致的流程如下
 1.个人客户端在TCP/IP Bootrom获得控制权进行自我检测
 2.发送请求获取IP
 3.服务器收到请求返回IP、网关和开机映像
 4.客户端下载映像文件
 5.利用开机映像开机（这个映像可以使操作系统），该映像包括kernel loader和压缩的kernel
 6.客户端机器根据下载的文件启动机器

## 3.2 系统启动流程
 1. 了解NTLDR的启动流程。
 >NTLDR启动流程分为预引导、引导和加载内核三个主要阶段
 预引导：执行POST检测内存和硬件设备，加载第一个物理扇区、加载并运行主引导记录（运行时
 查找活动分区），加载并执行活动分区的引导扇区，加载并初始化NTLDR文件。 
 引导：初始引导加载器、操作系统选择、硬件检测以及配置选择四个阶段。
 加载内核：加载各种内核程序
 
 1. 了解GRUB的启动流程。
 >GRUB启动流程分为四个阶段：BIOS引导、GRUB引导、内核、SYS V init初始化
 1、硬件初始化，加载GRUB启动引导管理器
 2、读取grub.conf文件显示启动菜单、加载kernel和initrd
 3、运行内核启动程序、加载initd文件系统装载驱动程序挂载根文件系统
 4、启动各种终端程序
 1. 比较NTLDR和GRUB的功能有差异。
 >加载内核的时间不同，另外GRUB的兼容性要优于前者
 1. 了解u-boot的功能。
 >u-boot，顾名思义即通用引导程序，可以引导X86的CPU，也可以引导ARM的CPU，还有PowerPC，MIPS之类的CPU。
 主要功能是操作Uboot，比如擦写Flash，网络下载数据

## 3.3 中断、异常和系统调用比较
 1. 举例说明Linux中有哪些中断，哪些异常？
 >Linux中断分为可屏蔽中断和不可屏蔽中断
 异常分为故障（如缺页异常处理程序）、陷阱（执行没有必要重新执行已终止的指令）、异常终止和编程异常（比如编程中的访问越界）
 
 1. Linux的系统调用有哪些？大致的功能分类有哪些？  (w2l1)
>Linux有200个以上的系统调用，主要分为进程控制、文件系统控制、系统控制、内存管理、网络管理、socket控制、
用户管理和进程间通信八类。其中文件系统控制又分为文件读写操作和文件系统操作；进程间通信又包括信号、消息
管道、信号量、共享内存等几个方面。这些系统函数都是用C写的。
```
  + 采分点：说明了Linux的大致数量（上百个），说明了Linux系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
 1. 以ucore lab8的answer为例，uCore的系统调用有哪些？大致的功能分类有哪些？(w2l1)
 >	查找ucore内核的syscall文件夹中的文件，可以发现ucore的系统调用有22个，分别属于进程控制、系统控制、
 文件系统控制三个主要的功能分类。
 ```
  + 采分点：说明了ucore的大致数量（二十几个），说明了ucore系统调用的主要分类（文件操作，进程管理，内存管理等）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.4 linux系统调用分析
 1. 通过分析[lab1_ex0](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex0.md)了解Linux应用的系统调用编写和含义。(w2l1)
>根据运行结果，
objdump可以显示文件的附加信息，可以有很多作用，比如使用objdump -d指令，得到了一大段汇编代码，所以objdump -d的作用是反汇编那些应该还有指令机器码
的section，-s 可以显示指定section的完整内容
nm列出文件的符号清单，
执行file得到一系列文件类型和文件属性的信息（比如lab1_ex0.exe得到的信息包含executable即可执行文件和X86-64bit，即文件的运行环境的属性），所以file
的作用是确定文件类型和属性。

lab1-ex0.s如下

.include "defines.h"
.data
hello:
	.string "hello world\n"

.globl	main
main:
	movl	$SYS_write,%eax
	movl	$STDOUT,%ebx
	movl	$hello,%ecx
	movl	$12,%edx
	int	$0x80

	ret
	
经过分析发现，在本例中	
eax寄存器存放系统调用，这里调用的是SYS_write
ebx是标准输出
ecx存放参数值，串
edx存放字符串长度
0x80退出
 ```
  + 采分点：说明了objdump，nm，file的大致用途，说明了系统调用的具体含义
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 
 ```
 
 1. 通过调试[lab1_ex1](https://github.com/chyyuu/ucore_lab/blob/master/related_info/lab1/lab1-ex1.md)了解Linux应用的系统调用执行过程。(w2l1)
 >strace常用来跟踪进程执行时的系统调用和所接收的信号，可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间
 strace存在的必要性是因为Linux系统中进程不能直接访问硬件设备，访问的时候需要必须由用户态切换至内核态。

 ```
  + 采分点：说明了strace的大致用途，说明了系统调用的具体执行过程（包括应用，CPU硬件，操作系统的执行过程）
  - 答案没有涉及上述两个要点；（0分）
  - 答案对上述两个要点中的某一个要点进行了正确阐述（1分）
  - 答案对上述两个要点进行了正确阐述（2分）
  - 答案除了对上述两个要点都进行了正确阐述外，还进行了扩展和更丰富的说明（3分）
 ```
 
## 3.5 ucore系统调用分析
 1. ucore的系统调用中参数传递代码分析。
 1. ucore的系统调用中返回结果的传递代码分析。
 1. 以ucore lab8的answer为例，分析ucore 应用的系统调用编写和含义。
 1. 以ucore lab8的answer为例，尝试修改并运行代码，分析ucore应用的系统调用执行过程。
 
## 3.6 请分析函数调用和系统调用的区别
 1. 请从代码编写和执行过程来说明。
   1. 说明`int`、`iret`、`call`和`ret`的指令准确功能
 
